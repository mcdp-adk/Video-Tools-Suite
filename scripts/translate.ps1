# Subtitle translation module
# Uses AI translation

# Load config (if not already loaded)
if (-not (Get-Command "Ensure-ConfigReady" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\config-manager.ps1"
}

# Dot source dependencies if not already loaded
if (-not (Get-Command "Import-SubtitleFile" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\subtitle-utils.ps1"
}
if (-not (Get-Command "Invoke-AiCompletion" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\ai-client.ps1"
}
if (-not (Get-Command "Get-AllGlossaryTerms" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\glossary.ps1"
}
if (-not (Get-Command "Get-LanguageDisplayName" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\lang-config.ps1"
}
if (-not (Get-Command "Show-Success" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\utils.ps1"
}
if (-not (Get-Command "Set-VtsWindowTitle" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\tui-utils.ps1"
}

# Configuration variables (set by config-manager.ps1 via Apply-ConfigToModules)
# $script:TargetLanguage
# $script:TranslateOutputDir
# $script:EmbedFontFile

#region Main Translation Function

# Main function: Translate subtitle file
function Invoke-SubtitleTranslator {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputPath,
        [string]$OutputPath = "",
        [string]$TargetLanguage = "",
        [switch]$SkipProofread,
        [switch]$GenerateAss,
        [switch]$EmbedFont,  # Use configured font for embedding
        [switch]$Quiet
    )

    if (-not (Test-Path -LiteralPath $InputPath)) {
        throw "Subtitle file not found: $InputPath"
    }

    # Use configured values if not specified
    if (-not $TargetLanguage) { $TargetLanguage = $script:TargetLanguage }

    if (-not $Quiet) {
        Write-Host ("=" * 60) -ForegroundColor Cyan
        Write-Host "Subtitle Translator" -ForegroundColor Yellow
        Write-Host ("=" * 60) -ForegroundColor Cyan
        Show-Detail "Target: $TargetLanguage"
        Write-Host ("=" * 60) -ForegroundColor Cyan
    }

    # Load subtitle file with auto-generated detection
    if (-not $Quiet) { Show-Info "Loading subtitle file..." }
    $subtitleData = Import-SubtitleFile -Path $InputPath -DetectAutoGenerated

    # Handle auto-generated subtitles with word-level timestamps
    if ($subtitleData.IsAutoGenerated) {
        if (-not $Quiet) {
            Show-Warning "Detected auto-generated subtitle with word-level timestamps"
            Show-Info "Processing $($subtitleData.Cues.Count) cues..."
        }

        # Use cue-based segmentation: process in batches
        $segments = Invoke-CueBasedSegmentation -Cues $subtitleData.Cues -Words $subtitleData.Words -Quiet:$Quiet

        # Convert segments to entries with timestamps
        $entries = ConvertTo-SubtitleEntriesFromSegments -Segments $segments -Words $subtitleData.Words

        if (-not $Quiet) { Show-Success "Created $($entries.Count) subtitle entries" }
    } else {
        $entries = $subtitleData.Entries
    }

    if (-not $entries -or $entries.Count -eq 0) {
        throw "No subtitle entries found in file"
    }

    if (-not $Quiet) { Show-Detail "Found $($entries.Count) subtitle entries" }

    # Check source language
    $langCheck = Test-SubtitleLanguage -Entries $entries -ExpectedLanguage "en"
    if (-not $Quiet) { Show-Detail "Detected language: $($langCheck.DetectedLanguage) (confidence: $($langCheck.Confidence))" }

    $isSameLanguage = ($langCheck.DetectedLanguage -eq $TargetLanguage) -or
                      ($TargetLanguage -match 'zh' -and $langCheck.DetectedLanguage -eq 'zh')
    if ($isSameLanguage -and -not $Quiet) {
        Show-Warning "Warning: Source language appears to be the same as target language"
    }

    # Translate using AI
    $bilingualEntries = Invoke-AiTranslateFlow -Entries $entries -TargetLanguage $TargetLanguage -SkipProofread:$SkipProofread -IsAutoGenerated:$subtitleData.IsAutoGenerated -Quiet:$Quiet

    # Apply text formatting to translations (Chinese spacing/punctuation)
    if ($TargetLanguage -match 'zh') {
        if (-not $Quiet) { Show-Info "Applying Chinese text formatting..." }
        $bilingualEntries = $bilingualEntries | ForEach-Object {
            $translationText = if ($_.Translation) { Format-ChineseText -Text $_.Translation } else { "" }
            @{
                StartTime = $_.StartTime
                EndTime = $_.EndTime
                Original = $_.Original
                Translation = $translationText
            }
        }
    }

    # Determine output path
    if (-not $OutputPath) {
        if (-not (Test-Path $script:TranslateOutputDir)) {
            New-Item -ItemType Directory -Path $script:TranslateOutputDir -Force | Out-Null
        }

        $file = Get-Item -LiteralPath $InputPath
        $baseName = $file.BaseName

        $OutputPath = Join-Path $script:TranslateOutputDir "$baseName.bilingual.ass"
    }

    # Generate ASS file
    if (-not $Quiet) { Show-Info "Generating bilingual ASS subtitle..." }

    # Set font name if embedding (use filename without extension)
    $fontParams = @{}
    if ($EmbedFont -and $script:EmbedFontFile) {
        $fontName = [System.IO.Path]::GetFileNameWithoutExtension($script:EmbedFontFile)
        $fontParams["FontName"] = $fontName
        if (-not $Quiet) { Show-Detail "Using embedded font: $fontName" }
    }

    $assContent = New-BilingualAssContent -BilingualEntries $bilingualEntries @fontParams
    Export-AssFile -Path $OutputPath -Content $assContent

    if (-not $Quiet) {
        Write-Host ""
        Show-Success "Translation complete!"
        Show-Detail "Output: $OutputPath"
    }

    return @{
        OutputPath = $OutputPath
        EntryCount = $bilingualEntries.Count
    }
}

#endregion

#region AI Translation Flow

function Invoke-AiTranslateFlow {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [string]$TargetLanguage = "Chinese (Simplified)",
        [switch]$SkipProofread,
        [switch]$IsAutoGenerated,
        [switch]$Quiet
    )

    # Check AI configuration
    if (-not $script:AiClient_ApiKey) {
        throw "AI API key not configured. Please set up in Settings."
    }

    # Step 1: Match glossaries (always)
    if (-not $Quiet) { Show-Info "Matching glossaries..." }
    Set-VtsWindowTitle -Phase GlossaryMatch -Status "Matching glossaries..."

    $selectedGlossaries = Select-RelevantGlossaries -Entries $Entries -Quiet:$Quiet

    if ($selectedGlossaries.Count -gt 0) {
        $glossary = Get-SelectedGlossaryTerms -GlossaryNames $selectedGlossaries
        if (-not $Quiet) {
            Show-Detail "Selected: $($selectedGlossaries -join ', ') ($($glossary.Count) terms)"
        }
    } else {
        $glossary = @{}
        if (-not $Quiet) { Show-Detail "No matching glossaries found" }
    }

    # Step 2: Source proofreading (auto-generated only)
    # NOTE: Disabled for now - kept for future use
    $entriesToTranslate = $Entries
    # if ($IsAutoGenerated) {
    #     if (-not $Quiet) { Show-Info "Source proofreading..." -NoBlankBefore }
    #     $entriesToTranslate = Invoke-SourceProofread -Entries $Entries -Glossary $glossary -Quiet:$Quiet
    # }

    # Step 3: Translate with AI
    if (-not $Quiet) { Show-Info "Translating with AI ($($script:AiClient_Model))..." }

    # Convert target language code to full name for AI
    $targetLangName = Get-LanguageDisplayName -LangCode $TargetLanguage

    $bilingualEntries = Invoke-SubtitleTranslate -Entries $entriesToTranslate -TargetLanguage $targetLangName -Glossary $glossary -Quiet:$Quiet

    # Step 4: Translation proofreading
    if (-not $SkipProofread) {
        if (-not $Quiet) { Show-Info "Proofreading translations..." }
        $bilingualEntries = Invoke-GlobalProofread -BilingualEntries $bilingualEntries -TargetLanguage $targetLangName -Quiet:$Quiet
    }

    return $bilingualEntries
}

#endregion

#region Command-line Interface

if ($MyInvocation.InvocationName -ne '.') {
    $cliPath = if ($args.Count -ge 1) { $args[0] } else { $null }
    if ($cliPath) {
        try {
            $result = Invoke-SubtitleTranslator -InputPath $cliPath
            Write-Host ""
            Show-Success "Success!"
        }
        catch {
            Show-Error "Error: $_"
            exit 1
        }
    } else {
        Show-Warning "Usage: translate.bat <subtitle_file>"
        Show-Hint "Translates subtitle file and generates bilingual ASS"
        Write-Host ""
        Show-Hint "Examples:"
        Show-Hint "  translate.bat video.en.vtt"
        Show-Hint "  translate.bat subtitles.srt"
        exit 1
    }
}

#endregion
