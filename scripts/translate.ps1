# Subtitle translation module
# Uses AI translation

# Dot source dependencies if not already loaded
if (-not (Get-Command "Import-SubtitleFile" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\subtitle-utils.ps1"
}
if (-not (Get-Command "Invoke-AiCompletion" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\ai-client.ps1"
}
if (-not (Get-Command "Get-AllGlossaryTerms" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\glossary.ps1"
}
if (-not (Get-Command "Get-LanguageDisplayName" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\lang-config.ps1"
}
if (-not (Get-Command "Show-Success" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\utils.ps1"
}

# Configuration (set by vts.ps1 from config.json)
$script:TargetLanguage = $script:DefaultTargetLanguage
$script:TranslateOutputDir = "$PSScriptRoot\..\output"

#region Main Translation Function

# Main function: Translate subtitle file
function Invoke-SubtitleTranslator {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputPath,
        [string]$OutputPath = "",
        [string]$TargetLanguage = "",
        [switch]$SkipProofread,
        [switch]$GenerateAss,
        [switch]$Quiet
    )

    if (-not (Test-Path -LiteralPath $InputPath)) {
        throw "Subtitle file not found: $InputPath"
    }

    # Use configured values if not specified
    if (-not $TargetLanguage) { $TargetLanguage = $script:TargetLanguage }

    if (-not $Quiet) {
        Write-Host ("=" * 60) -ForegroundColor Cyan
        Write-Host "Subtitle Translator" -ForegroundColor Yellow
        Write-Host ("=" * 60) -ForegroundColor Cyan
        Show-Detail "  Target: $TargetLanguage"
        Write-Host ("=" * 60) -ForegroundColor Cyan
        Write-Host ""
    }

    # Load subtitle file with auto-generated detection
    if (-not $Quiet) { Show-Info "Loading subtitle file..." }
    $subtitleData = Import-SubtitleFile -Path $InputPath -DetectAutoGenerated

    # Handle auto-generated subtitles with word-level timestamps
    if ($subtitleData.IsAutoGenerated) {
        if (-not $Quiet) {
            Show-Warning "Detected auto-generated subtitle with word-level timestamps"
            Show-Info "Processing $($subtitleData.Cues.Count) cues..."
        }

        # Use cue-based segmentation: process in batches
        $segments = Invoke-CueBasedSegmentation -Cues $subtitleData.Cues -Words $subtitleData.Words -Quiet:$Quiet

        # Convert segments to entries with timestamps
        $entries = ConvertTo-SubtitleEntriesFromSegments -Segments $segments -Words $subtitleData.Words

        if (-not $Quiet) { Show-Success "Created $($entries.Count) subtitle entries" }
    } else {
        $entries = $subtitleData.Entries
    }

    if ($entries.Count -eq 0) {
        throw "No subtitle entries found in file"
    }

    if (-not $Quiet) { Show-Detail "Found $($entries.Count) subtitle entries" }

    # Check source language
    $langCheck = Test-SubtitleLanguage -Entries $entries -ExpectedLanguage "en"
    if (-not $Quiet) { Show-Detail "Detected language: $($langCheck.DetectedLanguage) (confidence: $($langCheck.Confidence))" }

    $isSameLanguage = ($langCheck.DetectedLanguage -eq $TargetLanguage) -or
                      ($TargetLanguage -match 'zh' -and $langCheck.DetectedLanguage -eq 'zh')
    if ($isSameLanguage -and -not $Quiet) {
        Show-Warning "Warning: Source language appears to be the same as target language"
    }

    # Translate using AI
    $bilingualEntries = Invoke-AiTranslateFlow -Entries $entries -TargetLanguage $TargetLanguage -SkipProofread:$SkipProofread -Quiet:$Quiet

    # Apply text formatting to translations (Chinese spacing/punctuation)
    if ($TargetLanguage -match 'zh') {
        if (-not $Quiet) { Show-Info "Applying Chinese text formatting..." }
        $bilingualEntries = $bilingualEntries | ForEach-Object {
            $translationText = if ($_.Translation) { Format-ChineseText -Text $_.Translation } else { "" }
            @{
                StartTime = $_.StartTime
                EndTime = $_.EndTime
                Original = $_.Original
                Translation = $translationText
            }
        }
    }

    # Determine output path
    if (-not $OutputPath) {
        if (-not (Test-Path $script:TranslateOutputDir)) {
            New-Item -ItemType Directory -Path $script:TranslateOutputDir -Force | Out-Null
        }

        $file = Get-Item -LiteralPath $InputPath
        $baseName = $file.BaseName

        $OutputPath = Join-Path $script:TranslateOutputDir "$baseName.bilingual.ass"
    }

    # Generate ASS file
    if (-not $Quiet) { Show-Info "Generating bilingual ASS subtitle..." }
    $assContent = New-BilingualAssContent -BilingualEntries $bilingualEntries
    Export-AssFile -Path $OutputPath -Content $assContent

    if (-not $Quiet) {
        Write-Host ""
        Show-Success "Translation complete!"
        Show-Detail "Output: $OutputPath"
    }

    return @{
        OutputPath = $OutputPath
        EntryCount = $bilingualEntries.Count
    }
}

#endregion

#region AI Translation Flow

function Invoke-AiTranslateFlow {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [string]$TargetLanguage = "Chinese (Simplified)",
        [switch]$SkipProofread,
        [switch]$Quiet
    )

    # Check AI configuration
    if (-not $script:AiClient_ApiKey) {
        throw "AI API key not configured. Please set up in Settings."
    }

    # Load glossary
    if (-not $Quiet) { Show-Info "  Loading glossaries..." }
    $glossary = Get-AllGlossaryTerms
    if (-not $Quiet) { Show-Detail "    Loaded $($glossary.Count) terms" }

    # Optionally run AI segmentation for better sentence boundaries
    # (Skip for now as original timing is usually acceptable)

    # Translate with AI
    if (-not $Quiet) { Show-Info "  Translating with AI ($($script:AiClient_Model))..." }

    # Convert target language code to full name for AI
    $targetLangName = Get-LanguageDisplayName -LangCode $TargetLanguage

    $bilingualEntries = Invoke-SubtitleTranslate -Entries $Entries -TargetLanguage $targetLangName -Glossary $glossary

    # Run global proofreading
    if (-not $SkipProofread) {
        if (-not $Quiet) { Show-Info "  Running AI proofreading..." }
        $bilingualEntries = Invoke-GlobalProofread -BilingualEntries $bilingualEntries -TargetLanguage $targetLangName
    }

    return $bilingualEntries
}

#endregion

#region Command-line Interface

if ($MyInvocation.InvocationName -ne '.') {
    $cliPath = if ($args.Count -ge 1) { $args[0] } else { $null }
    if ($cliPath) {
        try {
            $result = Invoke-SubtitleTranslator -InputPath $cliPath
            Write-Host ""
            Show-Success "Success!"
        }
        catch {
            Show-Error "Error: $_"
            exit 1
        }
    } else {
        Show-Warning "Usage: translate.bat <subtitle_file>"
        Show-Hint "Translates subtitle file and generates bilingual ASS"
        Write-Host ""
        Show-Hint "Examples:"
        Show-Hint "  translate.bat video.en.vtt"
        Show-Hint "  translate.bat subtitles.srt"
        exit 1
    }
}

#endregion
