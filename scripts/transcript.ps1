# Transcript generation module
# Converts subtitle files to plain text transcripts

# Dot source utilities if not already loaded
if (-not (Get-Command "Show-Success" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\utils.ps1"
}
if (-not (Get-Command "Set-VtsWindowTitle" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\tui-utils.ps1"
}
if (-not (Get-Command "Import-SubtitleFile" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\subtitle-utils.ps1"
}
if (-not (Get-Command "Invoke-SentenceSegmentation" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\ai-client.ps1"
}

# Configuration
$script:TranscriptOutputDir = "$PSScriptRoot\..\output"

#region Core Functions

# Generate plain text transcript from subtitle entries
function ConvertTo-Transcript {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [switch]$IncludeTimestamps,
        [switch]$PreserveParagraphs
    )

    # Deduplicate consecutive entries with same text (handles YouTube auto-generated subtitles)
    $deduplicatedEntries = @()
    $lastText = ""
    foreach ($entry in $Entries) {
        $currentText = $entry.Text.Trim()
        if ($currentText -ne $lastText -and $currentText -ne "") {
            $deduplicatedEntries += $entry
            $lastText = $currentText
        }
    }
    $Entries = $deduplicatedEntries

    $lines = @()

    if ($IncludeTimestamps) {
        foreach ($entry in $Entries) {
            $timestamp = "{0:hh\:mm\:ss}" -f $entry.StartTime
            $lines += "[$timestamp] $($entry.Text)"
        }
    }
    elseif ($PreserveParagraphs) {
        # Group entries into paragraphs based on pauses
        $currentParagraph = @()
        $lastEndTime = $null

        foreach ($entry in $Entries) {
            if ($lastEndTime) {
                $gap = ($entry.StartTime - $lastEndTime).TotalSeconds
                if ($gap -gt 2) {
                    # Start new paragraph
                    if ($currentParagraph.Count -gt 0) {
                        $lines += ($currentParagraph -join ' ')
                        $lines += ""
                    }
                    $currentParagraph = @()
                }
            }

            $currentParagraph += $entry.Text
            $lastEndTime = $entry.EndTime
        }

        # Add final paragraph
        if ($currentParagraph.Count -gt 0) {
            $lines += ($currentParagraph -join ' ')
        }
    }
    else {
        # One entry per line (default mode)
        foreach ($entry in $Entries) {
            $lines += $entry.Text
        }
    }

    return ($lines -join "`n")
}

# Main function: Generate transcript from subtitle file
function Invoke-TranscriptGenerator {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputPath,
        [string]$OutputPath = "",
        [switch]$IncludeTimestamps,
        [switch]$PreserveParagraphs,
        [switch]$Quiet
    )

    if (-not (Test-Path -LiteralPath $InputPath)) {
        throw "Subtitle file not found: $InputPath"
    }

    # Save and set window title
    $originalTitle = Save-WindowTitle
    if (-not $Quiet) {
        Set-VtsWindowTitle -Phase Transcript -Status "Generating transcript..."
    }

    try {
        # Load subtitle file with auto-generated detection
        if (-not $Quiet) { Show-Info "Loading subtitle file..." }
        $subtitleData = Import-SubtitleFile -Path $InputPath -DetectAutoGenerated

        # Handle auto-generated subtitles
        if ($subtitleData.IsAutoGenerated) {
            if (-not $Quiet) {
                Show-Warning "Detected auto-generated subtitle, processing $($subtitleData.Cues.Count) cues..."
            }

            # Use cue-based segmentation
            $segments = Invoke-CueBasedSegmentation -Cues $subtitleData.Cues -Words $subtitleData.Words

            # Convert segments to entries format
            $entries = $segments | ForEach-Object {
                @{ Text = $_.Text }
            }
        } else {
            $entries = $subtitleData.Entries
        }

        if ($entries.Count -eq 0) {
            throw "No subtitle entries found in file"
        }

        if (-not $Quiet) { Show-Detail "Found $($entries.Count) entries" }

        # Generate transcript
        if (-not $Quiet) { Show-Info "Generating transcript..." }
        $transcript = ConvertTo-Transcript -Entries $entries -IncludeTimestamps:$IncludeTimestamps -PreserveParagraphs:$PreserveParagraphs

    # Determine output path
    if (-not $OutputPath) {
        if (-not (Test-Path $script:TranscriptOutputDir)) {
            New-Item -ItemType Directory -Path $script:TranscriptOutputDir -Force | Out-Null
        }
        $file = Get-Item -LiteralPath $InputPath
        $OutputPath = Join-Path $script:TranscriptOutputDir "$($file.BaseName)_transcript.txt"
    }

        # Write transcript
        $utf8WithBom = New-Object System.Text.UTF8Encoding($true)
        [System.IO.File]::WriteAllText($OutputPath, $transcript, $utf8WithBom)

        if (-not $Quiet) { Show-Success "Transcript saved to: $OutputPath" }

        return $OutputPath
    }
    finally {
        Restore-WindowTitle -Title $originalTitle
    }
}

#endregion

#region Command-line Interface

if ($MyInvocation.InvocationName -ne '.') {
    $cliPath = if ($args.Count -ge 1) { $args[0] } else { $null }
    if ($cliPath) {
        try {
            Write-Host ("=" * 48) -ForegroundColor Cyan
            Write-Host "Transcript Generator" -ForegroundColor Yellow
            Write-Host ("=" * 48) -ForegroundColor Cyan
            Write-Host ""

            $result = Invoke-TranscriptGenerator -InputPath $cliPath -PreserveParagraphs

            Write-Host ""
            Show-Success "Success!"
            Show-Detail "Output: $result"
        }
        catch {
            Show-Error "Error: $_"
            exit 1
        }
    } else {
        Show-Warning "Usage: transcript.bat <subtitle_file>"
        Show-Hint "Generates a plain text transcript from VTT or SRT subtitle file"
        Write-Host ""
        Show-Hint "Examples:"
        Show-Hint "  transcript.bat video.en.vtt"
        Show-Hint "  transcript.bat subtitles.srt"
        exit 1
    }
}

#endregion
