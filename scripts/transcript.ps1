# Transcript generation module
# Converts subtitle files to plain text transcripts

# Dot source subtitle utilities if not already loaded
if (-not (Get-Command "Import-SubtitleFile" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\subtitle-utils.ps1"
}
if (-not (Get-Command "Invoke-SentenceSegmentation" -ErrorAction SilentlyContinue)) {
    . "$PSScriptRoot\ai-client.ps1"
}

# Configuration
$script:TranscriptOutputDir = "$PSScriptRoot\..\output"

#region Core Functions

# Generate plain text transcript from subtitle entries
function ConvertTo-Transcript {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [switch]$IncludeTimestamps,
        [switch]$PreserveParagraphs
    )

    # Deduplicate consecutive entries with same text (handles YouTube auto-generated subtitles)
    $deduplicatedEntries = @()
    $lastText = ""
    foreach ($entry in $Entries) {
        $currentText = $entry.Text.Trim()
        if ($currentText -ne $lastText -and $currentText -ne "") {
            $deduplicatedEntries += $entry
            $lastText = $currentText
        }
    }
    $Entries = $deduplicatedEntries

    $lines = @()

    if ($IncludeTimestamps) {
        foreach ($entry in $Entries) {
            $timestamp = "{0:hh\:mm\:ss}" -f $entry.StartTime
            $lines += "[$timestamp] $($entry.Text)"
        }
    }
    elseif ($PreserveParagraphs) {
        # Group entries into paragraphs based on pauses
        $currentParagraph = @()
        $lastEndTime = $null

        foreach ($entry in $Entries) {
            if ($lastEndTime) {
                $gap = ($entry.StartTime - $lastEndTime).TotalSeconds
                if ($gap -gt 2) {
                    # Start new paragraph
                    if ($currentParagraph.Count -gt 0) {
                        $lines += ($currentParagraph -join ' ')
                        $lines += ""
                    }
                    $currentParagraph = @()
                }
            }

            $currentParagraph += $entry.Text
            $lastEndTime = $entry.EndTime
        }

        # Add final paragraph
        if ($currentParagraph.Count -gt 0) {
            $lines += ($currentParagraph -join ' ')
        }
    }
    else {
        # Simple continuous text
        $allText = ($Entries | ForEach-Object { $_.Text }) -join ' '

        # Clean up multiple spaces
        $allText = $allText -replace '\s+', ' '

        # Split into lines of ~80 characters at word boundaries
        $words = $allText -split '\s+'
        $currentLine = ""

        foreach ($word in $words) {
            if (($currentLine.Length + $word.Length + 1) -gt 80) {
                $lines += $currentLine.Trim()
                $currentLine = $word
            }
            else {
                $currentLine += " $word"
            }
        }

        if ($currentLine.Trim()) {
            $lines += $currentLine.Trim()
        }
    }

    return ($lines -join "`n")
}

# Main function: Generate transcript from subtitle file
function Invoke-TranscriptGenerator {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputPath,
        [string]$OutputPath = "",
        [switch]$IncludeTimestamps,
        [switch]$PreserveParagraphs,
        [switch]$Quiet
    )

    if (-not (Test-Path -LiteralPath $InputPath)) {
        throw "Subtitle file not found: $InputPath"
    }

    # Load subtitle file with auto-generated detection
    if (-not $Quiet) { Write-Host "Loading subtitle file..." -ForegroundColor Cyan }
    $subtitleData = Import-SubtitleFile -Path $InputPath -DetectAutoGenerated

    # Handle auto-generated subtitles
    if ($subtitleData.IsAutoGenerated) {
        if (-not $Quiet) {
            Write-Host "Detected auto-generated subtitle, using AI segmentation..." -ForegroundColor Yellow
        }

        # Use AI to segment into proper sentences
        $sentences = Invoke-SentenceSegmentation -FullText $subtitleData.FullText

        # Convert sentences to entries format
        $entries = $sentences | ForEach-Object {
            @{ Text = $_ }
        }
    } else {
        $entries = $subtitleData.Entries
    }

    if ($entries.Count -eq 0) {
        throw "No subtitle entries found in file"
    }

    if (-not $Quiet) { Write-Host "Found $($entries.Count) entries" -ForegroundColor Gray }

    # Generate transcript
    if (-not $Quiet) { Write-Host "Generating transcript..." -ForegroundColor Cyan }
    $transcript = ConvertTo-Transcript -Entries $entries -IncludeTimestamps:$IncludeTimestamps -PreserveParagraphs:$PreserveParagraphs

    # Determine output path
    if (-not $OutputPath) {
        if (-not (Test-Path $script:TranscriptOutputDir)) {
            New-Item -ItemType Directory -Path $script:TranscriptOutputDir -Force | Out-Null
        }
        $file = Get-Item -LiteralPath $InputPath
        $OutputPath = Join-Path $script:TranscriptOutputDir "$($file.BaseName)_transcript.txt"
    }

    # Write transcript
    $utf8WithBom = New-Object System.Text.UTF8Encoding($true)
    [System.IO.File]::WriteAllText($OutputPath, $transcript, $utf8WithBom)

    if (-not $Quiet) { Write-Host "Transcript saved to: $OutputPath" -ForegroundColor Green }

    return $OutputPath
}

# Generate transcript directly to a project folder
function Invoke-ProjectTranscriptGenerator {
    param(
        [Parameter(Mandatory=$true)]
        [string]$SubtitlePath,
        [Parameter(Mandatory=$true)]
        [string]$ProjectDir,
        [switch]$Quiet
    )

    if (-not (Test-Path -LiteralPath $SubtitlePath)) {
        throw "Subtitle file not found: $SubtitlePath"
    }

    if (-not (Test-Path -LiteralPath $ProjectDir)) {
        throw "Project directory not found: $ProjectDir"
    }

    $outputPath = Join-Path $ProjectDir "transcript.txt"

    return Invoke-TranscriptGenerator -InputPath $SubtitlePath -OutputPath $outputPath -PreserveParagraphs -Quiet:$Quiet
}

#endregion

#region Command-line Interface

if ($MyInvocation.InvocationName -ne '.') {
    $cliPath = if ($args.Count -ge 1) { $args[0] } else { $null }
    if ($cliPath) {
        try {
            Write-Host "================================================" -ForegroundColor Cyan
            Write-Host "Transcript Generator" -ForegroundColor Yellow
            Write-Host "================================================" -ForegroundColor Cyan
            Write-Host ""

            $result = Invoke-TranscriptGenerator -InputPath $cliPath -PreserveParagraphs

            Write-Host ""
            Write-Host "Success!" -ForegroundColor Green
            Write-Host "Output: $result" -ForegroundColor Gray
        }
        catch {
            Write-Host "Error: $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "Usage: transcript.bat <subtitle_file>" -ForegroundColor Yellow
        Write-Host "Generates a plain text transcript from VTT or SRT subtitle file" -ForegroundColor Gray
        Write-Host ""
        Write-Host "Examples:" -ForegroundColor Gray
        Write-Host "  transcript.bat video.en.vtt" -ForegroundColor Gray
        Write-Host "  transcript.bat subtitles.srt" -ForegroundColor Gray
        exit 1
    }
}

#endregion
