# Subtitle utilities for VTT/SRT parsing, ASS generation, and text formatting
# This module provides core subtitle processing functions

#region VTT Parser

# Parse auto-generated VTT with word-level timestamps
# Returns array of @{ Word; StartTime } or $null if not auto-generated format
function ConvertFrom-AutoGeneratedVtt {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Content
    )

    # Detect auto-generated format: contains word-level timestamps like <00:00:00.719><c>
    if ($Content -notmatch '<\d{2}:\d{2}:\d{2}\.\d{3}><c>') {
        return $null  # Not auto-generated format, use standard parsing
    }

    $words = @()

    # Split content into cue blocks
    $blocks = $Content -split '\r?\n\r?\n'

    foreach ($block in $blocks) {
        $lines = $block -split '\r?\n' | Where-Object { $_.Trim() }

        if ($lines.Count -lt 2) { continue }

        # Find timestamp line (contains -->)
        $timestampLineIndex = -1
        for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '-->') {
                $timestampLineIndex = $i
                break
            }
        }

        if ($timestampLineIndex -lt 0) { continue }

        $timestampLine = $lines[$timestampLineIndex]

        # Parse cue start time
        if ($timestampLine -notmatch '(\d{1,2}:)?(\d{2}):(\d{2})[.,](\d{3})\s*-->') {
            continue
        }

        $cueStartHours = if ($Matches[1]) { [int]($Matches[1] -replace ':', '') } else { 0 }
        $cueStartMinutes = [int]$Matches[2]
        $cueStartSeconds = [int]$Matches[3]
        $cueStartMillis = [int]$Matches[4]
        $cueStartTime = [TimeSpan]::new(0, $cueStartHours, $cueStartMinutes, $cueStartSeconds, $cueStartMillis)

        # Get text lines (everything after timestamp)
        $textLines = $lines[($timestampLineIndex + 1)..($lines.Count - 1)]
        $textContent = $textLines -join ' '

        # Parse word-level timestamps
        # Format: "firstWord<00:00:01.234><c> nextWord</c><00:00:02.345><c> anotherWord</c>"
        # The first word in a cue uses the cue start time

        # Extract first word (before any timestamp tag)
        if ($textContent -match '^([^<]+)') {
            $firstWord = $Matches[1].Trim()
            if ($firstWord) {
                $words += @{
                    Word = $firstWord
                    StartTime = $cueStartTime
                }
            }
        }

        # Extract subsequent words with their timestamps
        # Pattern: <timestamp><c> word</c>
        $wordMatches = [regex]::Matches($textContent, '<(\d{2}):(\d{2}):(\d{2})\.(\d{3})><c>\s*([^<]*)</c>')

        foreach ($match in $wordMatches) {
            $hours = [int]$match.Groups[1].Value
            $minutes = [int]$match.Groups[2].Value
            $seconds = [int]$match.Groups[3].Value
            $millis = [int]$match.Groups[4].Value
            $word = $match.Groups[5].Value.Trim()

            if ($word) {
                $words += @{
                    Word = $word
                    StartTime = [TimeSpan]::new(0, $hours, $minutes, $seconds, $millis)
                }
            }
        }
    }

    if ($words.Count -eq 0) {
        return $null
    }

    return $words
}

# Map sentences back to timestamps using word timing data
# Simple word-count based mapping to maintain sync with original audio
function ConvertTo-SubtitleEntriesFromSentences {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Sentences,
        [Parameter(Mandatory=$true)]
        [array]$Words
    )

    $entries = @()
    $wordIndex = 0

    foreach ($sentence in $Sentences) {
        if (-not $sentence -or $sentence.Trim() -eq '') { continue }
        if ($wordIndex -ge $Words.Count) { break }

        $startTime = $Words[$wordIndex].StartTime

        # Normalize sentence: remove punctuation, convert to lowercase, split into words
        $normalizedSentence = ($sentence -replace '[^\w\s'']', '' -replace '\s+', ' ').Trim().ToLower()
        $sentenceWords = @($normalizedSentence -split '\s+' | Where-Object { $_ })

        # Match words one by one against original word list
        $matchedCount = 0
        while ($wordIndex -lt $Words.Count -and $matchedCount -lt $sentenceWords.Count) {
            # Normalize original word
            $originalWord = ($Words[$wordIndex].Word -replace '[^\w'']', '').Trim().ToLower()
            $targetWord = $sentenceWords[$matchedCount]

            # Match check (allow partial matching for contractions like "don't" vs "dont")
            if ($originalWord -and $targetWord) {
                if ($originalWord -eq $targetWord -or
                    $originalWord.Contains($targetWord) -or
                    $targetWord.Contains($originalWord)) {
                    $matchedCount++
                }
            }
            $wordIndex++
        }

        # End time = next word's start time - 10ms (to prevent overlap)
        if ($wordIndex -lt $Words.Count) {
            $endTime = $Words[$wordIndex].StartTime - [TimeSpan]::FromMilliseconds(10)
        } else {
            # Last sentence - add 2 seconds buffer
            $lastIdx = [math]::Min($wordIndex - 1, $Words.Count - 1)
            $endTime = $Words[$lastIdx].StartTime + [TimeSpan]::FromSeconds(2)
        }

        # Ensure valid time range
        if ($endTime -le $startTime) {
            $endTime = $startTime + [TimeSpan]::FromSeconds(1)
        }

        $entries += @{
            StartTime = $startTime
            EndTime = $endTime
            Text = $sentence.Trim()
        }
    }

    return $entries
}

# Parse VTT content into subtitle entries
# Returns array of @{ StartTime; EndTime; Text }
function ConvertFrom-VttContent {
    param(
        [Parameter(Mandatory=$true, ParameterSetName='Path')]
        [string]$Path,
        [Parameter(Mandatory=$true, ParameterSetName='Content')]
        [string]$Content
    )

    if ($Path) {
        if (-not (Test-Path -LiteralPath $Path)) {
            throw "VTT file not found: $Path"
        }
        $Content = [System.IO.File]::ReadAllText($Path, [System.Text.Encoding]::UTF8)
    }

    $entries = @()

    # Remove BOM if present
    $Content = $Content -replace '^\xEF\xBB\xBF', ''

    # Split into blocks (separated by blank lines)
    $blocks = $Content -split '\r?\n\r?\n'

    foreach ($block in $blocks) {
        $lines = $block -split '\r?\n' | Where-Object { $_.Trim() }

        if ($lines.Count -lt 2) { continue }

        # Find timestamp line (contains -->)
        $timestampLineIndex = -1
        for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '-->') {
                $timestampLineIndex = $i
                break
            }
        }

        if ($timestampLineIndex -lt 0) { continue }

        $timestampLine = $lines[$timestampLineIndex]

        # Parse timestamp: 00:00:00.000 --> 00:00:05.000
        if ($timestampLine -match '(\d{1,2}:)?(\d{2}):(\d{2})[.,](\d{3})\s*-->\s*(\d{1,2}:)?(\d{2}):(\d{2})[.,](\d{3})') {
            $startHours = if ($Matches[1]) { [int]($Matches[1] -replace ':', '') } else { 0 }
            $startMinutes = [int]$Matches[2]
            $startSeconds = [int]$Matches[3]
            $startMillis = [int]$Matches[4]

            $endHours = if ($Matches[5]) { [int]($Matches[5] -replace ':', '') } else { 0 }
            $endMinutes = [int]$Matches[6]
            $endSeconds = [int]$Matches[7]
            $endMillis = [int]$Matches[8]

            $startTime = [TimeSpan]::new(0, $startHours, $startMinutes, $startSeconds, $startMillis)
            $endTime = [TimeSpan]::new(0, $endHours, $endMinutes, $endSeconds, $endMillis)

            # Get text lines (everything after timestamp)
            $textLines = $lines[($timestampLineIndex + 1)..($lines.Count - 1)]
            $text = ($textLines -join ' ').Trim()

            # Remove VTT tags like <c>, </c>, <00:00:00.000>, etc.
            $text = $text -replace '<[^>]+>', ''
            # Clean up multiple spaces
            $text = $text -replace '\s+', ' '
            $text = $text.Trim()

            if ($text) {
                $entries += @{
                    StartTime = $startTime
                    EndTime = $endTime
                    Text = $text
                }
            }
        }
    }

    return $entries
}

#endregion

#region SRT Parser

# Parse SRT content into subtitle entries
# Returns array of @{ StartTime; EndTime; Text }
function ConvertFrom-SrtContent {
    param(
        [Parameter(Mandatory=$true, ParameterSetName='Path')]
        [string]$Path,
        [Parameter(Mandatory=$true, ParameterSetName='Content')]
        [string]$Content
    )

    if ($Path) {
        if (-not (Test-Path -LiteralPath $Path)) {
            throw "SRT file not found: $Path"
        }
        $Content = [System.IO.File]::ReadAllText($Path, [System.Text.Encoding]::UTF8)
    }

    $entries = @()

    # Remove BOM if present
    $Content = $Content -replace '^\xEF\xBB\xBF', ''

    # Split into blocks (separated by blank lines)
    $blocks = $Content -split '\r?\n\r?\n'

    foreach ($block in $blocks) {
        $lines = $block -split '\r?\n' | Where-Object { $_.Trim() }

        if ($lines.Count -lt 2) { continue }

        # Find timestamp line (contains -->)
        $timestampLineIndex = -1
        for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '-->') {
                $timestampLineIndex = $i
                break
            }
        }

        if ($timestampLineIndex -lt 0) { continue }

        $timestampLine = $lines[$timestampLineIndex]

        # Parse timestamp: 00:00:00,000 --> 00:00:05,000
        if ($timestampLine -match '(\d{2}):(\d{2}):(\d{2})[,.](\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})[,.](\d{3})') {
            $startTime = [TimeSpan]::new(0, [int]$Matches[1], [int]$Matches[2], [int]$Matches[3], [int]$Matches[4])
            $endTime = [TimeSpan]::new(0, [int]$Matches[5], [int]$Matches[6], [int]$Matches[7], [int]$Matches[8])

            # Get text lines (everything after timestamp)
            $textLines = $lines[($timestampLineIndex + 1)..($lines.Count - 1)]
            $text = ($textLines -join ' ').Trim()

            # Remove SRT formatting tags
            $text = $text -replace '<[^>]+>', ''
            $text = $text -replace '\{[^}]+\}', ''
            # Clean up multiple spaces
            $text = $text -replace '\s+', ' '
            $text = $text.Trim()

            if ($text) {
                $entries += @{
                    StartTime = $startTime
                    EndTime = $endTime
                    Text = $text
                }
            }
        }
    }

    return $entries
}

#endregion

#region Language Detection

# Detect subtitle language based on character analysis
# Returns language code: 'en', 'zh', 'ja', 'ko', 'mixed', 'unknown'
function Test-SubtitleLanguage {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [string]$ExpectedLanguage = 'en'
    )

    $allText = ($Entries | ForEach-Object { $_.Text }) -join ' '

    $chineseCount = ([regex]::Matches($allText, '[\u4E00-\u9FFF]')).Count
    $japaneseCount = ([regex]::Matches($allText, '[\u3040-\u309F\u30A0-\u30FF]')).Count
    $koreanCount = ([regex]::Matches($allText, '[\uAC00-\uD7AF]')).Count
    $latinCount = ([regex]::Matches($allText, '[a-zA-Z]')).Count

    $totalChars = $chineseCount + $japaneseCount + $koreanCount + $latinCount

    if ($totalChars -eq 0) {
        return @{
            DetectedLanguage = 'unknown'
            IsMatch = $false
            Confidence = 0
        }
    }

    $chineseRatio = $chineseCount / $totalChars
    $japaneseRatio = $japaneseCount / $totalChars
    $koreanRatio = $koreanCount / $totalChars
    $latinRatio = $latinCount / $totalChars

    $detectedLanguage = 'unknown'
    $confidence = 0

    if ($latinRatio -gt 0.7) {
        $detectedLanguage = 'en'
        $confidence = $latinRatio
    } elseif ($chineseRatio -gt 0.3) {
        $detectedLanguage = 'zh'
        $confidence = $chineseRatio
    } elseif ($japaneseRatio -gt 0.1) {
        $detectedLanguage = 'ja'
        $confidence = $japaneseRatio
    } elseif ($koreanRatio -gt 0.3) {
        $detectedLanguage = 'ko'
        $confidence = $koreanRatio
    } elseif ($latinRatio -gt 0.3 -and ($chineseRatio -gt 0.1 -or $japaneseRatio -gt 0.05)) {
        $detectedLanguage = 'mixed'
        $confidence = 0.5
    }

    $isMatch = ($detectedLanguage -eq $ExpectedLanguage) -or
               ($ExpectedLanguage -eq 'en' -and $detectedLanguage -eq 'en') -or
               ($ExpectedLanguage -eq 'zh' -and $detectedLanguage -eq 'zh')

    return @{
        DetectedLanguage = $detectedLanguage
        IsMatch = $isMatch
        Confidence = [math]::Round($confidence, 2)
        Stats = @{
            Chinese = [math]::Round($chineseRatio, 2)
            Japanese = [math]::Round($japaneseRatio, 2)
            Korean = [math]::Round($koreanRatio, 2)
            Latin = [math]::Round($latinRatio, 2)
        }
    }
}

#endregion

#region ASS Generation

# Convert TimeSpan to ASS timestamp format (H:MM:SS.cc)
function ConvertTo-AssTimestamp {
    param([TimeSpan]$Time)

    $hours = [int]$Time.Hours
    $minutes = $Time.Minutes.ToString("00")
    $seconds = $Time.Seconds.ToString("00")
    $centiseconds = [math]::Floor($Time.Milliseconds / 10).ToString("00")

    return "${hours}:${minutes}:${seconds}.${centiseconds}"
}

# Generate bilingual ASS subtitle content
# $BilingualEntries should be array of @{ StartTime; EndTime; Original; Translation }
# Uses same MarginV for both styles - player auto-stacks when outputting Original first, then Translation
function New-BilingualAssContent {
    param(
        [Parameter(Mandatory=$true)]
        [array]$BilingualEntries,
        [string]$OriginalFont = "Noto Sans",
        [int]$OriginalFontSize = 38,
        [string]$TranslationFont = "Microsoft YaHei",
        [int]$TranslationFontSize = 58,
        [int]$PlayResX = 1920,
        [int]$PlayResY = 1080
    )

    # Both styles use same MarginV=35, player auto-stacks
    # Output order: Original first (pushed down), Translation second (on top)
    # Result: Translation (Chinese) on top, Original (English) below
    $header = @"
[Script Info]
Title: Bilingual Subtitles
ScriptType: v4.00+
PlayResX: $PlayResX
PlayResY: $PlayResY
WrapStyle: 0
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Translation,$TranslationFont,$TranslationFontSize,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,3,0,2,2,30,30,35,1
Style: Original,$OriginalFont,$OriginalFontSize,&H00CCCCCC,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,3,0,2,2,30,30,35,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"@

    $events = @()

    foreach ($entry in $BilingualEntries) {
        $start = ConvertTo-AssTimestamp -Time $entry.StartTime
        $end = ConvertTo-AssTimestamp -Time $entry.EndTime

        # Escape special ASS characters
        $original = $entry.Original -replace '\\', '\\\\' -replace '\{', '\\{' -replace '\}', '\\}'
        $translation = $entry.Translation -replace '\\', '\\\\' -replace '\{', '\\{' -replace '\}', '\\}'

        # Output Original first (will be pushed down), then Translation (will be on top)
        # This achieves: Chinese on top, English below
        if ($original) {
            $events += "Dialogue: 0,$start,$end,Original,,0,0,0,,$original"
        }
        if ($translation) {
            $events += "Dialogue: 0,$start,$end,Translation,,0,0,0,,$translation"
        }
    }

    return $header + "`n" + ($events -join "`n") + "`n"
}

# Generate monolingual ASS subtitle content
function New-MonolingualAssContent {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [string]$FontName = "Noto Sans CJK SC",
        [int]$FontSize = 48,
        [int]$PlayResX = 1920,
        [int]$PlayResY = 1080
    )

    $header = @"
[Script Info]
Title: Subtitles
ScriptType: v4.00+
PlayResX: $PlayResX
PlayResY: $PlayResY
WrapStyle: 0
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,$FontName,$FontSize,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,3,0,2,2,30,30,35,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"@

    $events = @()

    foreach ($entry in $Entries) {
        $start = ConvertTo-AssTimestamp -Time $entry.StartTime
        $end = ConvertTo-AssTimestamp -Time $entry.EndTime

        # Escape special ASS characters
        $text = $entry.Text -replace '\\', '\\\\' -replace '{', '\{' -replace '}', '\}'

        $events += "Dialogue: 0,$start,$end,Default,,0,0,0,,$text"
    }

    return $header + "`n" + ($events -join "`n") + "`n"
}

#endregion

#region Text Formatting

# Format Chinese text: replace punctuation with spaces, add spacing between Chinese and alphanumeric
function Format-ChineseText {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Text
    )

    # Chinese punctuation marks to replace with space
    $punctuationToReplace = @(
        [char]0xFF0C,  # Fullwidth Comma
        [char]0x3002,  # Ideographic Full Stop
        [char]0x3001   # Ideographic Comma
    )

    $result = $Text

    # Replace Chinese punctuation marks with space
    foreach ($punct in $punctuationToReplace) {
        $result = $result.Replace($punct, ' ')
    }

    # Add spacing between Chinese characters and alphanumeric characters
    $result = $result -replace '([\u4E00-\u9FFF])([a-zA-Z0-9])', '$1 $2'
    $result = $result -replace '([a-zA-Z0-9])([\u4E00-\u9FFF])', '$1 $2'

    # Clean up multiple spaces
    $result = $result -replace '\s+', ' '

    return $result.Trim()
}

# Apply text formatting to subtitle entries
function Format-SubtitleEntries {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries
    )

    $formattedEntries = @()

    foreach ($entry in $Entries) {
        $formattedEntries += @{
            StartTime = $entry.StartTime
            EndTime = $entry.EndTime
            Text = Format-ChineseText -Text $entry.Text
        }
    }

    return $formattedEntries
}

#endregion

#region Utility Functions

# Merge consecutive subtitle entries with same text
function Merge-SubtitleEntries {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [int]$MaxGapMs = 500
    )

    if ($Entries.Count -eq 0) { return @() }

    $merged = @()
    $current = $Entries[0].Clone()

    for ($i = 1; $i -lt $Entries.Count; $i++) {
        $entry = $Entries[$i]
        $gap = ($entry.StartTime - $current.EndTime).TotalMilliseconds

        if ($entry.Text -eq $current.Text -and $gap -le $MaxGapMs) {
            # Extend current entry
            $current.EndTime = $entry.EndTime
        } else {
            $merged += $current
            $current = $entry.Clone()
        }
    }

    $merged += $current

    return $merged
}

# Extract complete sentences from subtitle entries
function Get-CompleteSentences {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries
    )

    $sentences = @()
    $currentSentence = ""
    $startTime = $null
    $endTime = $null

    foreach ($entry in $Entries) {
        if (-not $startTime) {
            $startTime = $entry.StartTime
        }
        $endTime = $entry.EndTime

        $currentSentence += " " + $entry.Text

        # Check if sentence ends (period, question mark, exclamation mark)
        if ($entry.Text -match '[.!?]$') {
            $sentences += @{
                StartTime = $startTime
                EndTime = $endTime
                Text = $currentSentence.Trim()
            }
            $currentSentence = ""
            $startTime = $null
        }
    }

    # Add remaining text as last sentence
    if ($currentSentence.Trim()) {
        $sentences += @{
            StartTime = $startTime
            EndTime = $endTime
            Text = $currentSentence.Trim()
        }
    }

    return $sentences
}

# Save ASS content to file
function Export-AssFile {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path,
        [Parameter(Mandatory=$true)]
        [string]$Content
    )

    # Write with UTF-8 BOM for compatibility
    $utf8WithBom = New-Object System.Text.UTF8Encoding($true)
    [System.IO.File]::WriteAllText($Path, $Content, $utf8WithBom)

    return $Path
}

# Load subtitle file (auto-detect format)
# Import subtitle file with auto-generated subtitle detection
# Returns @{ Entries; IsAutoGenerated; Words } where:
#   - Entries: standard subtitle entries (may be empty for auto-generated if AI processing needed)
#   - IsAutoGenerated: $true if word-level timestamps detected
#   - Words: array of @{ Word; StartTime } for auto-generated subtitles
function Import-SubtitleFile {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path,
        [switch]$DetectAutoGenerated
    )

    if (-not (Test-Path -LiteralPath $Path)) {
        throw "Subtitle file not found: $Path"
    }

    $extension = [System.IO.Path]::GetExtension($Path).ToLower()

    # For VTT files, check if it's auto-generated format
    if ($extension -eq '.vtt' -and $DetectAutoGenerated) {
        $content = [System.IO.File]::ReadAllText($Path, [System.Text.Encoding]::UTF8)
        $words = ConvertFrom-AutoGeneratedVtt -Content $content

        if ($words) {
            # Auto-generated subtitle detected - return words for AI processing
            return @{
                Entries = @()
                IsAutoGenerated = $true
                Words = $words
                FullText = ($words | ForEach-Object { $_.Word }) -join ' '
            }
        }
    }

    # Standard subtitle parsing
    $entries = switch ($extension) {
        '.vtt' { ConvertFrom-VttContent -Path $Path }
        '.srt' { ConvertFrom-SrtContent -Path $Path }
        default { throw "Unsupported subtitle format: $extension (supported: .vtt, .srt)" }
    }

    return @{
        Entries = $entries
        IsAutoGenerated = $false
        Words = @()
        FullText = ''
    }
}

#endregion
