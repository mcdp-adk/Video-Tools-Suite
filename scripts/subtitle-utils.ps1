# Subtitle utilities for VTT/SRT parsing, ASS generation, and text formatting
# This module provides core subtitle processing functions

#region VTT Parser

# Decode HTML entities in subtitle text (e.g., &gt; -> >, &amp; -> &)
function ConvertFrom-HtmlEntities {
    param([string]$Text)
    if (-not $Text) { return $Text }
    return [System.Net.WebUtility]::HtmlDecode($Text)
}

# Parse auto-generated VTT with word-level timestamps
# Returns array of cues: @{ StartTime; EndTime; Words = @(@{ Word; StartTime }, ...) }
# or $null if not auto-generated format
function ConvertFrom-AutoGeneratedVtt {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Content
    )

    # Detect auto-generated format: contains word-level timestamps like <00:00:00.719><c>
    if ($Content -notmatch '<\d{2}:\d{2}:\d{2}\.\d{3}><c>') {
        return $null  # Not auto-generated format
    }

    $cues = @()
    $blocks = $Content -split '\r?\n\r?\n'

    foreach ($block in $blocks) {
        $lines = $block -split '\r?\n'

        # Find timestamp line (contains -->)
        $timestampLine = $null
        $timestampLineIndex = -1
        for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '-->') {
                $timestampLine = $lines[$i]
                $timestampLineIndex = $i
                break
            }
        }

        if (-not $timestampLine) { continue }

        # Parse cue start and end time
        if ($timestampLine -notmatch '(\d{1,2}:)?(\d{2}):(\d{2})[.,](\d{3})\s*-->\s*(\d{1,2}:)?(\d{2}):(\d{2})[.,](\d{3})') {
            continue
        }

        $cueStartHours = if ($Matches[1]) { [int]($Matches[1] -replace ':', '') } else { 0 }
        $cueStartMinutes = [int]$Matches[2]
        $cueStartSeconds = [int]$Matches[3]
        $cueStartMillis = [int]$Matches[4]
        $cueStartTime = [TimeSpan]::new(0, $cueStartHours, $cueStartMinutes, $cueStartSeconds, $cueStartMillis)

        $cueEndHours = if ($Matches[5]) { [int]($Matches[5] -replace ':', '') } else { 0 }
        $cueEndMinutes = [int]$Matches[6]
        $cueEndSeconds = [int]$Matches[7]
        $cueEndMillis = [int]$Matches[8]
        $cueEndTime = [TimeSpan]::new(0, $cueEndHours, $cueEndMinutes, $cueEndSeconds, $cueEndMillis)

        # Find the line with <c> tags (new words line)
        $newWordsLine = $null
        for ($i = $timestampLineIndex + 1; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '<c>') {
                $newWordsLine = $lines[$i]
                break
            }
        }

        if (-not $newWordsLine) { continue }

        # Extract words from this cue
        $cueWords = @()

        # Extract first word (before any timestamp tag)
        if ($newWordsLine -match '^([^<]+)') {
            $firstWord = ConvertFrom-HtmlEntities $Matches[1].Trim()
            if ($firstWord) {
                $cueWords += @{
                    Word = $firstWord
                    StartTime = $cueStartTime
                }
            }
        }

        # Extract subsequent words with their timestamps
        $wordMatches = [regex]::Matches($newWordsLine, '<(\d{2}):(\d{2}):(\d{2})\.(\d{3})><c>\s*([^<]*)</c>')

        foreach ($match in $wordMatches) {
            $hours = [int]$match.Groups[1].Value
            $minutes = [int]$match.Groups[2].Value
            $seconds = [int]$match.Groups[3].Value
            $millis = [int]$match.Groups[4].Value
            $word = ConvertFrom-HtmlEntities $match.Groups[5].Value.Trim()

            if ($word) {
                $cueWords += @{
                    Word = $word
                    StartTime = [TimeSpan]::new(0, $hours, $minutes, $seconds, $millis)
                }
            }
        }

        # Only add cues that have words
        if ($cueWords.Count -gt 0) {
            $cues += @{
                StartTime = $cueStartTime
                EndTime = $cueEndTime
                Words = $cueWords
            }
        }
    }

    if ($cues.Count -eq 0) {
        return $null
    }

    return $cues
}

# Flatten cue array to word array (for backward compatibility)
# Input: array of cues from ConvertFrom-AutoGeneratedVtt
# Output: flat array of @{ Word; StartTime; CueIndex }
function ConvertFrom-CuesToWords {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Cues
    )

    $words = @()
    for ($cueIndex = 0; $cueIndex -lt $Cues.Count; $cueIndex++) {
        $cue = $Cues[$cueIndex]
        foreach ($word in $cue.Words) {
            $words += @{
                Word = $word.Word
                StartTime = $word.StartTime
                CueIndex = $cueIndex
            }
        }
    }
    return $words
}

# Convert word-based segments to subtitle entries with timestamps
# Input: segments from Invoke-WordBasedSegmentation, words array with timestamps
function ConvertTo-SubtitleEntriesFromSegments {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Segments,  # Array of @{ StartIndex; EndIndex; Text }
        [Parameter(Mandatory=$true)]
        [array]$Words      # Array of @{ Word; StartTime }
    )

    $entries = @()
    $totalWords = $Words.Count

    foreach ($segment in $Segments) {
        $startIdx = $segment.StartIndex
        $endIdx = $segment.EndIndex

        if ($startIdx -lt 0 -or $startIdx -ge $totalWords) { continue }
        if ($endIdx -lt 0 -or $endIdx -ge $totalWords) { $endIdx = $totalWords - 1 }

        $startTime = $Words[$startIdx].StartTime

        # End time: next word's start - 10ms, or last word + 2s
        if ($endIdx + 1 -lt $totalWords) {
            $endTime = $Words[$endIdx + 1].StartTime - [TimeSpan]::FromMilliseconds(10)
        } else {
            $endTime = $Words[$endIdx].StartTime + [TimeSpan]::FromSeconds(2)
        }

        # Ensure valid time range
        if ($endTime -le $startTime) {
            $endTime = $startTime + [TimeSpan]::FromSeconds(1)
        }

        $entries += @{
            StartTime = $startTime
            EndTime = $endTime
            Text = $segment.Text
        }
    }

    return $entries
}

# Parse VTT content into subtitle entries
# Returns array of @{ StartTime; EndTime; Text }
function ConvertFrom-VttContent {
    param(
        [Parameter(Mandatory=$true, ParameterSetName='Path')]
        [string]$Path,
        [Parameter(Mandatory=$true, ParameterSetName='Content')]
        [string]$Content
    )

    if ($Path) {
        if (-not (Test-Path -LiteralPath $Path)) {
            throw "VTT file not found: $Path"
        }
        $Content = [System.IO.File]::ReadAllText($Path, [System.Text.Encoding]::UTF8)
    }

    $entries = @()

    # Remove BOM if present
    $Content = $Content -replace '^\xEF\xBB\xBF', ''

    # Split into blocks (separated by blank lines)
    $blocks = $Content -split '\r?\n\r?\n'

    foreach ($block in $blocks) {
        $lines = $block -split '\r?\n' | Where-Object { $_.Trim() }

        if ($lines.Count -lt 2) { continue }

        # Find timestamp line (contains -->)
        $timestampLineIndex = -1
        for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '-->') {
                $timestampLineIndex = $i
                break
            }
        }

        if ($timestampLineIndex -lt 0) { continue }

        $timestampLine = $lines[$timestampLineIndex]

        # Parse timestamp: 00:00:00.000 --> 00:00:05.000
        if ($timestampLine -match '(\d{1,2}:)?(\d{2}):(\d{2})[.,](\d{3})\s*-->\s*(\d{1,2}:)?(\d{2}):(\d{2})[.,](\d{3})') {
            $startHours = if ($Matches[1]) { [int]($Matches[1] -replace ':', '') } else { 0 }
            $startMinutes = [int]$Matches[2]
            $startSeconds = [int]$Matches[3]
            $startMillis = [int]$Matches[4]

            $endHours = if ($Matches[5]) { [int]($Matches[5] -replace ':', '') } else { 0 }
            $endMinutes = [int]$Matches[6]
            $endSeconds = [int]$Matches[7]
            $endMillis = [int]$Matches[8]

            $startTime = [TimeSpan]::new(0, $startHours, $startMinutes, $startSeconds, $startMillis)
            $endTime = [TimeSpan]::new(0, $endHours, $endMinutes, $endSeconds, $endMillis)

            # Get text lines (everything after timestamp)
            $textLines = $lines[($timestampLineIndex + 1)..($lines.Count - 1)]
            $text = ($textLines -join ' ').Trim()

            # Remove VTT tags like <c>, </c>, <00:00:00.000>, etc.
            $text = $text -replace '<[^>]+>', ''
            # Clean up multiple spaces
            $text = $text -replace '\s+', ' '
            $text = $text.Trim()
            # Decode HTML entities
            $text = ConvertFrom-HtmlEntities $text

            if ($text) {
                $entries += @{
                    StartTime = $startTime
                    EndTime = $endTime
                    Text = $text
                }
            }
        }
    }

    return $entries
}

#endregion

#region SRT Parser

# Parse SRT content into subtitle entries
# Returns array of @{ StartTime; EndTime; Text }
function ConvertFrom-SrtContent {
    param(
        [Parameter(Mandatory=$true, ParameterSetName='Path')]
        [string]$Path,
        [Parameter(Mandatory=$true, ParameterSetName='Content')]
        [string]$Content
    )

    if ($Path) {
        if (-not (Test-Path -LiteralPath $Path)) {
            throw "SRT file not found: $Path"
        }
        $Content = [System.IO.File]::ReadAllText($Path, [System.Text.Encoding]::UTF8)
    }

    $entries = @()

    # Remove BOM if present
    $Content = $Content -replace '^\xEF\xBB\xBF', ''

    # Split into blocks (separated by blank lines)
    $blocks = $Content -split '\r?\n\r?\n'

    foreach ($block in $blocks) {
        $lines = $block -split '\r?\n' | Where-Object { $_.Trim() }

        if ($lines.Count -lt 2) { continue }

        # Find timestamp line (contains -->)
        $timestampLineIndex = -1
        for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '-->') {
                $timestampLineIndex = $i
                break
            }
        }

        if ($timestampLineIndex -lt 0) { continue }

        $timestampLine = $lines[$timestampLineIndex]

        # Parse timestamp: 00:00:00,000 --> 00:00:05,000
        if ($timestampLine -match '(\d{2}):(\d{2}):(\d{2})[,.](\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})[,.](\d{3})') {
            $startTime = [TimeSpan]::new(0, [int]$Matches[1], [int]$Matches[2], [int]$Matches[3], [int]$Matches[4])
            $endTime = [TimeSpan]::new(0, [int]$Matches[5], [int]$Matches[6], [int]$Matches[7], [int]$Matches[8])

            # Get text lines (everything after timestamp)
            $textLines = $lines[($timestampLineIndex + 1)..($lines.Count - 1)]
            $text = ($textLines -join ' ').Trim()

            # Remove SRT formatting tags
            $text = $text -replace '<[^>]+>', ''
            $text = $text -replace '\{[^}]+\}', ''
            # Clean up multiple spaces
            $text = $text -replace '\s+', ' '
            $text = $text.Trim()
            # Decode HTML entities
            $text = ConvertFrom-HtmlEntities $text

            if ($text) {
                $entries += @{
                    StartTime = $startTime
                    EndTime = $endTime
                    Text = $text
                }
            }
        }
    }

    return $entries
}

#endregion

#region Language Detection

# Detect subtitle language based on character analysis
# Returns language code: 'en', 'zh', 'ja', 'ko', 'mixed', 'unknown'
function Test-SubtitleLanguage {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Entries,
        [string]$ExpectedLanguage = 'en'
    )

    $allText = ($Entries | ForEach-Object { $_.Text }) -join ' '

    $chineseCount = ([regex]::Matches($allText, '[\u4E00-\u9FFF]')).Count
    $japaneseCount = ([regex]::Matches($allText, '[\u3040-\u309F\u30A0-\u30FF]')).Count
    $koreanCount = ([regex]::Matches($allText, '[\uAC00-\uD7AF]')).Count
    $latinCount = ([regex]::Matches($allText, '[a-zA-Z]')).Count

    $totalChars = $chineseCount + $japaneseCount + $koreanCount + $latinCount

    if ($totalChars -eq 0) {
        return @{
            DetectedLanguage = 'unknown'
            IsMatch = $false
            Confidence = 0
        }
    }

    $chineseRatio = $chineseCount / $totalChars
    $japaneseRatio = $japaneseCount / $totalChars
    $koreanRatio = $koreanCount / $totalChars
    $latinRatio = $latinCount / $totalChars

    $detectedLanguage = 'unknown'
    $confidence = 0

    if ($latinRatio -gt 0.7) {
        $detectedLanguage = 'en'
        $confidence = $latinRatio
    } elseif ($chineseRatio -gt 0.3) {
        $detectedLanguage = 'zh'
        $confidence = $chineseRatio
    } elseif ($japaneseRatio -gt 0.1) {
        $detectedLanguage = 'ja'
        $confidence = $japaneseRatio
    } elseif ($koreanRatio -gt 0.3) {
        $detectedLanguage = 'ko'
        $confidence = $koreanRatio
    } elseif ($latinRatio -gt 0.3 -and ($chineseRatio -gt 0.1 -or $japaneseRatio -gt 0.05)) {
        $detectedLanguage = 'mixed'
        $confidence = 0.5
    }

    $isMatch = ($detectedLanguage -eq $ExpectedLanguage) -or
               ($ExpectedLanguage -eq 'en' -and $detectedLanguage -eq 'en') -or
               ($ExpectedLanguage -eq 'zh' -and $detectedLanguage -eq 'zh')

    return @{
        DetectedLanguage = $detectedLanguage
        IsMatch = $isMatch
        Confidence = [math]::Round($confidence, 2)
        Stats = @{
            Chinese = [math]::Round($chineseRatio, 2)
            Japanese = [math]::Round($japaneseRatio, 2)
            Korean = [math]::Round($koreanRatio, 2)
            Latin = [math]::Round($latinRatio, 2)
        }
    }
}

#endregion

#region ASS Generation

# Convert TimeSpan to ASS timestamp format (H:MM:SS.cc)
function ConvertTo-AssTimestamp {
    param([TimeSpan]$Time)

    $hours = [int]$Time.Hours
    $minutes = $Time.Minutes.ToString("00")
    $seconds = $Time.Seconds.ToString("00")
    $centiseconds = [math]::Floor($Time.Milliseconds / 10).ToString("00")

    return "${hours}:${minutes}:${seconds}.${centiseconds}"
}

# Generate bilingual ASS subtitle content
# $BilingualEntries should be array of @{ StartTime; EndTime; Original; Translation }
# Uses same MarginV for both styles - player auto-stacks when outputting Original first, then Translation
function New-BilingualAssContent {
    param(
        [Parameter(Mandatory=$true)]
        [array]$BilingualEntries,
        [string]$FontName = "Arial",  # Font for both styles (Arial when not embedding, configured font when embedding)
        [int]$OriginalFontSize = 38,
        [int]$TranslationFontSize = 58,
        [int]$PlayResX = 1920,
        [int]$PlayResY = 1080
    )

    # Both styles use same MarginV=35, player auto-stacks
    # Output order: Original first (pushed down), Translation second (on top)
    # Result: Translation (Chinese) on top, Original (English) below
    $header = @"
[Script Info]
Title: Bilingual Subtitles
ScriptType: v4.00+
PlayResX: $PlayResX
PlayResY: $PlayResY
WrapStyle: 0
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Translation,$FontName,$TranslationFontSize,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,3,0,2,2,30,30,35,1
Style: Original,$FontName,$OriginalFontSize,&H00CCCCCC,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,3,0,2,2,30,30,35,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"@

    $events = @()

    foreach ($entry in $BilingualEntries) {
        $start = ConvertTo-AssTimestamp -Time $entry.StartTime
        $end = ConvertTo-AssTimestamp -Time $entry.EndTime

        # Escape special ASS characters
        $original = $entry.Original -replace '\\', '\\\\' -replace '\{', '\\{' -replace '\}', '\\}'
        $translation = $entry.Translation -replace '\\', '\\\\' -replace '\{', '\\{' -replace '\}', '\\}'

        # Output Original first (will be pushed down), then Translation (will be on top)
        # This achieves: Chinese on top, English below
        if ($original) {
            $events += "Dialogue: 0,$start,$end,Original,,0,0,0,,$original"
        }
        if ($translation) {
            $events += "Dialogue: 0,$start,$end,Translation,,0,0,0,,$translation"
        }
    }

    return $header + "`n" + ($events -join "`n") + "`n"
}

#endregion

#region Text Formatting

# Format Chinese text: replace punctuation with spaces, add spacing between Chinese and alphanumeric
function Format-ChineseText {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Text
    )

    # Chinese punctuation marks to replace with space
    $punctuationToReplace = @(
        [char]0xFF0C,  # Fullwidth Comma
        [char]0x3002,  # Ideographic Full Stop
        [char]0x3001   # Ideographic Comma
    )

    $result = $Text

    # Replace Chinese punctuation marks with space
    foreach ($punct in $punctuationToReplace) {
        $result = $result.Replace($punct, ' ')
    }

    # Add spacing between Chinese characters and alphanumeric characters
    $result = $result -replace '([\u4E00-\u9FFF])([a-zA-Z0-9])', '$1 $2'
    $result = $result -replace '([a-zA-Z0-9])([\u4E00-\u9FFF])', '$1 $2'

    # Clean up multiple spaces
    $result = $result -replace '\s+', ' '

    return $result.Trim()
}

#endregion

#region Utility Functions

# Save ASS content to file
function Export-AssFile {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path,
        [Parameter(Mandatory=$true)]
        [string]$Content
    )

    # Write with UTF-8 BOM for compatibility
    $utf8WithBom = New-Object System.Text.UTF8Encoding($true)
    [System.IO.File]::WriteAllText($Path, $Content, $utf8WithBom)

    return $Path
}

# Load subtitle file (auto-detect format)
# Import subtitle file with auto-generated subtitle detection
# Returns @{ Entries; IsAutoGenerated; Cues; Words; FullText } where:
#   - Entries: standard subtitle entries (may be empty for auto-generated if AI processing needed)
#   - IsAutoGenerated: $true if word-level timestamps detected
#   - Cues: array of @{ StartTime; EndTime; Words } for auto-generated subtitles
#   - Words: flat array of @{ Word; StartTime } for auto-generated subtitles
#   - FullText: concatenated text from all words
function Import-SubtitleFile {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path,
        [switch]$DetectAutoGenerated
    )

    if (-not (Test-Path -LiteralPath $Path)) {
        throw "Subtitle file not found: $Path"
    }

    $extension = [System.IO.Path]::GetExtension($Path).ToLower()

    # For VTT files, check if it's auto-generated format
    if ($extension -eq '.vtt' -and $DetectAutoGenerated) {
        $content = [System.IO.File]::ReadAllText($Path, [System.Text.Encoding]::UTF8)
        $cues = ConvertFrom-AutoGeneratedVtt -Content $content

        if ($cues) {
            # Auto-generated subtitle detected - return cue structure
            $words = ConvertFrom-CuesToWords -Cues $cues
            return @{
                Entries = @()
                IsAutoGenerated = $true
                Cues = $cues
                Words = $words
                FullText = ($words | ForEach-Object { $_.Word }) -join ' '
            }
        }
    }

    # Standard subtitle parsing
    $entries = switch ($extension) {
        '.vtt' { ConvertFrom-VttContent -Path $Path }
        '.srt' { ConvertFrom-SrtContent -Path $Path }
        default { throw "Unsupported subtitle format: $extension (supported: .vtt, .srt)" }
    }

    return @{
        Entries = $entries
        IsAutoGenerated = $false
        Cues = @()
        Words = @()
        FullText = ''
    }
}

#endregion
